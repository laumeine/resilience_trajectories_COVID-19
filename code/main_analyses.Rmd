---
title: "Analyses for 'Look After Yourself: Students Consistently Showing High Resilience Engaged in More Self Care and Proved More Resilient During the COVID 19 Pandemic'"
author: "Laura E. Meine"
date: "27.09.2021"
output:
  html_document:
    self_contained: no
    number_sections: yes
    theme: flatly
    toc: yes
    toc_float: yes
  word_document:
    toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = FALSE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center")
```

# Script Overview
Built with R `r getRversion()`

Data from Boosterit project cohorts 3 and 4, matched according to data collection time points:  
Cohort 3: T2-T5  
Cohort 4: T0-T3

TODOs  
- save class probabilities in case you want to check whether there are ids with low probs, not easily assigned to one class  
- translate all variables to English, then load curated datasets here ("Kohorte" --> cohort)

```{r set stage, include=FALSE}
# load required libraries
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, # data formatting, ggplot2
               magrittr, # piping %<>%
               Rmisc, # summarySE
               rstatix, # pipe-friendly basic stats
               afex, # ANOVA
               corrplot, Hmisc, # correlation matrix
               mlogit,  # multinomial logistic regression
               emmeans, # post-hoc comparisons
               lm.beta, # get standardized betas
               car) # vif, dwt

source("R_functions/summarySEwithin2.R") # within-subject standard errors
source("R_functions/laura_theme.R") # standard ggplot theme

# deal with conflicting functions
summarize <- dplyr::summarize
recode <- dplyr::recode

# define 4 theme colours to use (colourblind-friendly, s. http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/)
colour1 = "#009E73" # green
colour2 = "#0072B2" # blue 
colour3 = "#F0E442" # yellow
colour4 = "#D55E00" # red 

# define new function so that scale returns a vector, not a matrix
scale_this <- function(x) as.vector(scale(x))

# define new funtion for mean centering
center_this <- function(x) as.vector(scale(x, scale=FALSE))
```

```{r import and format data}
data_long <- read.csv("../data/data_matched_long.csv", header=T, sep="\t") # data T0-T3, long format
data_wide <- read.csv("../data/data_matched_wide.csv", header=T, sep="\t") # data T0-T3, wide format
data_pandemic <- read.csv("../data/data_matched_pandemic.csv", header=T, sep="\t") # data pandemic
classes <- read.table("Mplus_files/02_lcga_output_4-class.txt", header=F) # trajectory class assignment output after LGCA analysis in Mplus

classes <- cbind(data_wide[1], classes$V13) # add id to classes
colnames(classes) <- c("Code", "class")
classes$class <- as.factor(classes$class)
classes$class <- recode(classes$class, "1"="low", "2"="high", "3"="medium", "4"="mediumlow")

write.table(classes, "../data/RF_trajectory_classes.csv", sep="\t", col.names = T, row.names = F)

# add classes to data
data_wide <- data_wide %>% left_join(classes)
data_long <- data_long %>% left_join(classes)

data_wide$Code <- as.factor(data_wide$Code)

# merge classes & pandemic data
data_wide_pandemic <- list(classes, data_pandemic) %>% reduce(left_join, by = "Code")
data_wide_pandemic$Code <- as.factor(data_wide_pandemic$Code)
data_wide_pandemic <- data_wide_pandemic %>% 
  filter(! is.na(Kohorte)) # 108/133 participants completed follow-up
```

# Sample Descriptives

```{r sample descriptives}
N <- nrow(data_wide) # sample size

female <- (table(data_wide$Gender)[2]/nrow(data_wide))*100 # % female 

# age
age.min <- min(data_wide$Age, na.rm=T)
age.max <- max(data_wide$Age, na.rm=T)
age.m <- mean(data_wide$Age, na.rm=T) 
age.sd <- sd(data_wide$Age, na.rm=T)

cohort4 <- (table(data_wide$Kohorte)[2]/nrow(data_wide))*100 # % cohort 4 
```
Data from *N* = `r round(N,2)` participants aged `r round(age.min,2)`-`r round(age.max,2)` was analyzed (`r round(female,2)` % female, age: *M* = `r round(age.m,2)`, *SD* = `r round(age.sd,2)`).

```{r sample descriptives - COVID-19 sample}
Np <- nrow(data_wide_pandemic) # sample size (pandemic follow-up)

femaleP <- (table(data_wide_pandemic$Gender)[2]/nrow(data_wide_pandemic))*100 # % female 

# age
age.minP <- min(data_wide_pandemic$Age, na.rm=T)
age.maxP <- max(data_wide_pandemic$Age, na.rm=T)
age.mP <- mean(data_wide_pandemic$Age, na.rm=T) 
age.sdP <- sd(data_wide_pandemic$Age, na.rm=T)

cohort4P <- (table(data_wide_pandemic$Kohorte)[2]/nrow(data_wide_pandemic))*100 # % cohort 4 

# Do you belong to a risk group for severe COVID-19?
table(data_wide_pandemic$COR_F_T4_1) # 1=yes, 2=no, 3=unsure
riskgroup <- (table(data_wide_pandemic$COR_F_T4_1)[1]/nrow(data_wide_pandemic))*100 

# Have you tested positiv for COVID-19?
table(data_wide_pandemic$COR_F_T4_2) # 1=yes, 2=no --> only 1 participant reported testing positive

# symptom severity
data_wide_pandemic$COR_F_T4_3 # the one participant who was infected reported 3=symptoms with fever, treated at home

# quarantining?
table(data_wide_pandemic$COR_F_T4_4) # -1=no suspected infection, no quarantine necessary, 1=no, 2=yes, at home
quarantine_home <- (table(data_wide_pandemic$COR_F_T4_4)[3]/nrow(data_wide_pandemic))*100 

# Agreement with government-imposed measures
# "The measures taken by officials to prevent the spread of the Corona virus are sensible and appropriate." 
# 1=completely disagree to 5=completely agree
hist(data_wide_pandemic$COR_F_T4_5)
agree_measures.m <- mean(data_wide_pandemic$COR_F_T4_5)
agree_measures.sd <- sd(data_wide_pandemic$COR_F_T4_5)

# Following government-mandated rules
# "I follow the recommended measures to limit the spread of Corona virus." 
# 1=completely untrue to 5=completely true
hist(data_wide_pandemic$COR_F_T4_6)
follow_measures.m <- mean(data_wide_pandemic$COR_F_T4_6)
follow_measures.sd <- sd(data_wide_pandemic$COR_F_T4_6)
```


# Resilient Functioning Trajectories

Hypothesis 1:
There are distinct classes of trajectories.

```{r resilient functioning scores}
# plot relationship between mental health and stress components for T0-T3 to visualize individual resilient functioning scores
options(scipen=999)

# T0
mT0 <- lm(mhPCA_T0 ~ stressPCA_T0, data_wide); summary(mT0) # linear regression
colresT0 <- as.numeric(residuals(mT0)>0)+2 # assign 2 to all residuals below 0 (i.e. R default value for red) and 3 to all above 0 (i.e. green)
disT0 <- predict(mT0) # distance between points and regression line

RFT0 <- ggplot(data_wide, aes(stressPCA_T0, mhPCA_T0)) + 
  geom_point(color=colresT0,size=3) + 
  geom_smooth(se=T, method="lm", col='black') +
  geom_segment(aes(xend=stressPCA_T0, yend=disT0), col=colresT0) +
  labs(y="Mental Health", x="Stressor Load", title="T0") +
  laura_theme() + theme(axis.title.x=element_text(size=12),
                        axis.title.y=element_text(size=12),
                        axis.text=element_text(size=12))

hT0 <- ggplot(data_wide, aes(x=RF_T0)) + 
  geom_histogram(aes(y = ..density..), binwidth=0.3, color="black", fill="gray") +
  stat_function(fun = dnorm, color="blue", 
                arg = list(mean = mean(data_wide$RF_T0),
                           sd = sd(data_wide$RF_T0))) + 
  labs(x="Regression Residuals", title="T0") +
  laura_theme() + theme(axis.title.x=element_text(size=12),
                        axis.title.y=element_text(size=12),
                        axis.text=element_text(size=12))

# T1
mT1 <- lm(mhPCA_T1 ~ stressPCA_T1, data_wide); summary(mT1) # linear regression
colresT1 <- as.numeric(residuals(mT1)>0)+2
disT1 <- predict(mT1)

RFT1 <- ggplot(data_wide, aes(stressPCA_T1, mhPCA_T1)) + 
  geom_point(color=colresT1,size=3) + 
  geom_smooth(se=T, method="lm", col='black') +
  geom_segment(aes(xend=stressPCA_T1, yend=disT1), col=colresT1) +
  labs(y="", x="Stressor Load", title="T1") +
  laura_theme() + theme(axis.title.x=element_text(size=12), 
                        axis.text=element_text(size=12))

hT1 <- ggplot(data_wide, aes(x=RF_T1)) + 
  geom_histogram(aes(y = ..density..), binwidth=0.3, color="black", fill="gray") +
  stat_function(fun = dnorm, color="blue", 
                arg = list(mean = mean(data_wide$RF_T1),
                           sd = sd(data_wide$RF_T1))) + 
  labs(y="", x="Regression Residuals", title="T1") +
  laura_theme() + theme(axis.title.x=element_text(size=12), 
                        axis.text=element_text(size=12))

# T2
mT2 <- lm(mhPCA_T2 ~ stressPCA_T2, data_wide); summary(mT2) # linear regression
colresT2 <- as.numeric(residuals(mT2)>0)+2
disT2 <- predict(mT2)

RFT2 <- ggplot(data_wide, aes(stressPCA_T2, mhPCA_T2)) + 
  geom_point(color=colresT2,size=3) + 
  geom_smooth(se=T, method="lm", col='black') +
  geom_segment(aes(xend=stressPCA_T2, yend=disT2), col=colresT2) +
  labs(y="", x="Stressor Load", title="T2") +
  laura_theme() + theme(axis.title.x=element_text(size=12), 
                        axis.text=element_text(size=12))

hT2 <- ggplot(data_wide, aes(x=RF_T2)) + 
  geom_histogram(aes(y = ..density..), binwidth=0.3, color="black", fill="gray") +
  stat_function(fun = dnorm, color="blue", 
                arg = list(mean = mean(data_wide$RF_T2),
                           sd = sd(data_wide$RF_T2))) + 
  labs(y="", x="Regression Residuals", title="T2") +
  laura_theme() + theme(axis.title.x=element_text(size=12), 
                        axis.text=element_text(size=12))

# T3
mT3 <- lm(mhPCA_T3 ~ stressPCA_T3, data_wide); summary(mT3) # linear regression
colresT3 <- as.numeric(residuals(mT3)>0)+2
disT3 <- predict(mT3)

RFT3 <- ggplot(data_wide, aes(stressPCA_T3, mhPCA_T3)) + 
  geom_point(color=colresT3,size=3) + 
  geom_smooth(se=T, method="lm", col='black') +
  geom_segment(aes(xend=stressPCA_T3, yend=disT3), col=colresT3) +
  labs(y="", x="Stressor Load", title="T3") +
  laura_theme() + theme(axis.title.x=element_text(size=12), 
                        axis.text=element_text(size=12))

hT3 <- ggplot(data_wide, aes(x=RF_T3)) + 
  geom_histogram(aes(y = ..density..), binwidth=0.3, color="black", fill="gray") +
  stat_function(fun = dnorm, color="blue", 
                arg = list(mean = mean(data_wide$RF_T3),
                           sd = sd(data_wide$RF_T3))) + 
  labs(y="", x="Regression Residuals", title="T3") +
  laura_theme() + theme(axis.title.x=element_text(size=12), 
                        axis.text=element_text(size=12))

# T4
mT4 <- lm(mhPCA_P ~ stressPCA_P, data_wide_pandemic); summary(mT4) # linear regression
colresT4 <- as.numeric(residuals(mT4)>0)+2
disT4 <- predict(mT4)

RFT4 <- ggplot(data_wide_pandemic, aes(stressPCA_P, mhPCA_P)) + 
  geom_point(color=colresT4,size=3) + 
  geom_smooth(se=T, method="lm", col='black') +
  geom_segment(aes(xend=stressPCA_P, yend=disT4), col=colresT4) +
  labs(y="", x="Stressor Load", title="T4") +
  laura_theme() + theme(axis.title.x=element_text(size=12), 
                        axis.text=element_text(size=12))

hT4 <- ggplot(data_wide_pandemic, aes(x=RF_P)) + 
  geom_histogram(aes(y = ..density..), binwidth=0.3, color="black", fill="gray") +
  stat_function(fun = dnorm, color="blue", 
                arg = list(mean = mean(data_wide_pandemic$RF_P),
                           sd = sd(data_wide_pandemic$RF_P))) + 
  labs(y="", x="Regression Residuals", title="T4") +
  laura_theme() + theme(axis.title.x=element_text(size=12), 
                        axis.text=element_text(size=12))

require(gridExtra)
RF_scores <- grid.arrange(RFT0, RFT1, RFT2, RFT3, RFT4,
                          hT0, hT1, hT2, hT3, hT4, ncol=5, top="Resilient Functioning")
```

```{r resilient functioning trajectories}
RF_class_means <- summarySEwithin2(data_long, measurevar="RF", betweenvar="class", withinvar="timepoint", idvar="Code", conf.interval=.95)

# classes
# 1 = low
# 2 = high
# 3 = medium
# 4 = medium-to-low ("mediumlow")

# percentages per class
class1_l <- (table(data_wide$class)[1]/nrow(data_wide))*100
class2_h <- (table(data_wide$class)[2]/nrow(data_wide))*100
class3_m <- (table(data_wide$class)[3]/nrow(data_wide))*100
class4_ml <- (table(data_wide$class)[4]/nrow(data_wide))*100
```
Latent class growth analysis (LCGA) in Mplus revealed 4 distinct classes of resilient functioning trajectories: stable over time at higher (`r round(class2_h,2)`%) and lower (`r round(class3_m,2)`%) levels of resilient functioning, decreasing over time (`r round(class4_ml,2)`%), and slightly increasing over time (`r round(class1_l,2)`%).

## Plot Mplus Model
```{r plot Mplus trajectories}
# technical 7 output
RF <- c(-2.278, -1.859, -1.411, -1.038, # class 1
        0.839, 0.901, 1.081, 0.926, # class 2
        -0.246, -0.111, 0.015, 0.144, # class 3
        0.431, -0.342, -1.339, -1.641) # class 4
class <- rep(1:4, each=4)
timepoint <- rep(c("T0", "T1", "T2", "T3"), 4)

mplus_output <- data.frame(class, timepoint, RF)
mplus_output$class <- as.factor(mplus_output$class)
mplus_output$timepoint <- as.factor(mplus_output$timepoint)
 
# plot trajectories
Mplustrajectories <- ggplot(mplus_output, aes(x=timepoint, y=RF, group=class, color=class)) +
  geom_line(size=1.5) +
  geom_point(aes(shape=class), size=4) +
  scale_y_continuous(breaks=seq(-3,2,1), limits=c(-3,2)) +
  labs(y="Resilient Functioning", x="Time") +
  scale_color_manual(values=c(colour1, colour2, colour3, colour4), 
                     labels=c("low (9.0%)", "high (28.6%)", "medium (46.6%)", "medium-to-low (15.8%)"),
                     name="Trajectory Class") +
  scale_shape_manual(values=c(15,19,18,17),
                     labels=c("low (9.0%)", "high (28.6%)", "medium (46.6%)", "medium-to-low (15.8%)"),
                     name="Trajectory Class") +
  laura_theme() #+ theme(legend.position="none")
Mplustrajectories
```

## Plot Trajectories including individual data
```{r plot individual trajectories}
# plot trajectories
trajectories <- ggplot(data_long, aes(x=factor(timepoint), y=RF, colour=class)) +
  geom_line(aes(group=Code), size=1, alpha=.3) +
  geom_line(data=RF_class_means, aes(group=class, x=timepoint, y=RF), size=1.5) +
  geom_errorbar(data=RF_class_means, aes(ymin=RF-se, ymax=RF+se), size=1.5, width =.2) +
  scale_y_continuous(breaks=seq(-4,4,1), limits=c(-4,4)) +
  labs(y="Resilient Functioning", x="Time Point") +
  scale_colour_manual(values=c(colour1, colour2, colour3, colour4), 
                      name="Trajectory") +
  laura_theme()
trajectories
```

## Class Descriptives

### Cohort distribution
```{r class descriptives - cohort distribution}
RF_class_cohort <- data_wide %>%
  group_by(class) %>%
  tally(mean(Kohorte==4)*100) # % cohort 4

# Chi-square test
chisq.test(data_wide$Kohorte, data_wide$class) # cohort and class membership are dependent!
```

### Gender
```{r class descriptives - gender}
RF_class_gender <- data_wide %>%
  group_by(class) %>%
  tally(mean(Gender==2)*100) # % female

# Chi-square test
chisq.test(data_wide$Gender, data_wide$class) # Gender and class membership are independent
```

### Age
```{r class descriptives - age}
RF_class_age <- data_wide %>%
  group_by(class) %>%
  summarize(mean = mean(Age),
            sd = sd(Age))

# check assumptions for one-way ANOVA
ageModel <- lm(Age ~ class, data_wide)

# homogeneity of variance
plot(ageModel, 1) 
levene_test(ageModel)

# normality of residuals
plot(ageModel, 2)
shapiro.test(residuals(ageModel)) # non-normal distribution

# use Kruskal-Wallis test instead of ANOVA
kruskal.test(Age ~ class, data_wide) # n.s.
```

Since resilient functioning score does not directly show how different classes score on stress and mental health, we output the average across time points for all measures that make up the score (BSI, WHO, DH, LES).

### BSI
```{r class descriptives - BSI}
# get mean across time points
data_wide <- data_wide %>%
  mutate(BSI_mean_INV = rowMeans(across(matches("^BSI"))))

# output mean and sd by class
RF_class_means_BSI <- data_wide %>%
  group_by(class) %>%
  summarise_at(vars(BSI_mean_INV),
               list(mean = mean,
                    sd = sd))

# get outlier IDs
bsiOutlierIDs <- data_wide %>%
  identify_outliers(BSI_mean_INV)

# to be conservative and not exclude too much data, we will only consider extreme outliers
bsiOutlierIDs$Code[bsiOutlierIDs$is.extreme==T] # no extreme outliers

# check assumptions for one-way ANOVA
bsiModel <- lm(BSI_mean_INV ~ class, data_wide)

# homogeneity of variance
plot(bsiModel, 1) 
levene_test(bsiModel)

# normality of residuals
plot(bsiModel, 2)
shapiro.test(residuals(bsiModel)) # non-normal distribution

# use Kruskal-Wallis test instead of ANOVA
kruskal.test(BSI_mean_INV ~ class, data_wide) # p < .001

# plot trajectories of BSI
RF_class_means_bsi <- summarySEwithin2(data_long, measurevar="BSI_GSI_INV", betweenvar="class", withinvar="timepoint", idvar="Code", conf.interval=.95)

BSItrajectories <- ggplot(RF_class_means_bsi, aes(x=timepoint, y=BSI_GSI_INV, group=class, color=class)) +
  geom_line(size=1.5) +
  geom_point(aes(shape=class), size=4) +
  scale_y_continuous(breaks=seq(0,72,12), limits=c(0,72)) + # cover range of questionnaire
  labs(y="inverted GSI of the BSI-18", x="Time") +
  scale_color_manual(values=c(colour1, colour2, colour3, colour4), 
                     labels=c("low (9.0%)", "high (28.6%)", "medium (46.6%)", "medium-to-low (15.8%)"),
                     name="Trajectory Class") +
  scale_shape_manual(values=c(15,19,18,17),
                     labels=c("low (9.0%)", "high (28.6%)", "medium (46.6%)", "medium-to-low (15.8%)"),
                     name="Trajectory Class") +
  laura_theme() + theme(legend.position="none")
BSItrajectories
```

### WHO
```{r class descriptives - WHO}
data_wide <- data_wide %>%
  mutate(WHO_mean = rowMeans(across(matches("^WHO"))))

RF_class_means_WHO <- data_wide %>%
  group_by(class) %>%
  summarise_at(vars(WHO_mean),
               list(mean = mean,
                    sd = sd))

# get outlier IDs
whoOutlierIDs <- data_wide %>%
  identify_outliers(WHO_mean) # none

# check assumptions for one-way ANOVA
whoModel <- lm(WHO_mean ~ class, data_wide)

# homogeneity of variance
plot(whoModel, 1) 
levene_test(whoModel)

# normality of residuals
plot(whoModel, 2)
shapiro.test(residuals(whoModel)) 

# one-way ANOVA
who.fit <- aov_ez("Code", "WHO_mean", data_wide, between="class")
nice(who.fit, es="pes") # p < .001

# plot trajectories of WHO
RF_class_means_who <- summarySEwithin2(data_long, measurevar="WHO_Percent", betweenvar="class", withinvar="timepoint", idvar="Code", conf.interval=.95)

WHOtrajectories <- ggplot(RF_class_means_who, aes(x=timepoint, y=WHO_Percent, group=class, color=class)) +
  geom_line(size=1.5) +
  geom_point(aes(shape=class), size=4) +
  scale_y_continuous(breaks=seq(0,100,20), limits=c(0,100)) +
  labs(y="WHO-5", x="Time") +
  scale_color_manual(values=c(colour1, colour2, colour3, colour4), 
                     labels=c("low (9.0%)", "high (28.6%)", "medium (46.6%)", "medium-to-low (15.8%)"),
                     name="Trajectory Class") +
  scale_shape_manual(values=c(15,19,18,17),
                     labels=c("low (9.0%)", "high (28.6%)", "medium (46.6%)", "medium-to-low (15.8%)"),
                     name="Trajectory Class") +
  laura_theme() + theme(legend.position="none")
WHOtrajectories
```

### Frequency of microstressors
```{r class descriptives - DH}
DH_freqs <- data_wide %>% select("DH_T0_Frequency", "DH_T1_Frequency", "DH_T2_Frequency", "DH_T3_Frequency")
data_wide$DH_mean_Frequency <- rowMeans(DH_freqs)

RF_class_means_DH <- data_wide %>%
  group_by(class) %>%
  summarise_at(vars(DH_mean_Frequency),
               list(mean = mean,
                    sd = sd))

# get outlier IDs
dhOutlierIDs <- data_wide %>%
  identify_outliers(DH_mean_Frequency)

# to be conservative and not exclude too much data, we will only consider extreme outliers
dhOutlierIDs$Code[dhOutlierIDs$is.extreme==T] # no extreme outliers

# check assumptions for one-way ANOVA
dhModel <- lm(DH_mean_Frequency ~ class, data_wide)

# homogeneity of variance
plot(dhModel, 1) 
levene_test(dhModel)

# normality of residuals
plot(dhModel, 2)
shapiro.test(residuals(dhModel)) # non-normal distribution

# use Kruskal-Wallis test instead of ANOVA
kruskal.test(DH_mean_Frequency ~ class, data_wide) # p < .05

# plot trajectories of DH freq
RF_class_means_dh <- summarySEwithin2(data_long, measurevar="DH_Frequency", betweenvar="class", withinvar="timepoint", idvar="Code", conf.interval=.95)

DHtrajectories <- ggplot(RF_class_means_dh, aes(x=timepoint, y=DH_Frequency, group=class, color=class)) +
  geom_line(size=1.5) +
  geom_point(aes(shape=class), size=4) +
  #scale_y_continuous(breaks=seq(20,80,20), limits=c(20,80)) +
  labs(y="Microstressor Frequency", x="Time") +
  scale_color_manual(values=c(colour1, colour2, colour3, colour4), 
                     labels=c("low (9.0%)", "high (28.6%)", "medium (46.6%)", "medium-to-low (15.8%)"),
                     name="Trajectory Class") +
  scale_shape_manual(values=c(15,19,18,17),
                     labels=c("low (9.0%)", "high (28.6%)", "medium (46.6%)", "medium-to-low (15.8%)"),
                     name="Trajectory Class") +
  laura_theme() + theme(legend.position="none")
DHtrajectories
```

### Count of stressful life events
```{r class descriptives - LES}
LES_counts <- data_wide %>% select("LES_T0_Count", "LES_T1_Count", "LES_T2_Count", "LES_T3_Count")
data_wide$LES_mean_Count <- rowMeans(LES_counts)

RF_class_means_LES <- data_wide %>%
  group_by(class) %>%
  summarise_at(vars(LES_mean_Count),
               list(mean = mean,
                    sd = sd))

# get outlier IDs
lesOutlierIDs <- data_wide %>%
  identify_outliers(LES_mean_Count)

# to be conservative and not exclude too much data, we will only consider extreme outliers
lesOutlierIDs$Code[lesOutlierIDs$is.extreme==T] # no extreme outliers

# check assumptions for one-way ANOVA
lesModel <- lm(LES_mean_Count ~ class, data_wide)

# homogeneity of variance
plot(lesModel, 1) 
levene_test(lesModel)

# normality of residuals
plot(lesModel, 2)
shapiro.test(residuals(lesModel)) # non-normal distribution

# use Kruskal-Wallis test instead of ANOVA
kruskal.test(LES_mean_Count ~ class, data_wide) # p = .06

# plot trajectories of LES freq
RF_class_means_les <- summarySEwithin2(data_long, measurevar="LES_Count", betweenvar="class", withinvar="timepoint", idvar="Code", conf.interval=.95)

LEStrajectories <- ggplot(RF_class_means_les, aes(x=timepoint, y=LES_Count, group=class, color=class)) +
  geom_line(size=1.5) +
  geom_point(aes(shape=class), size=4) +
  scale_y_continuous(breaks=seq(1,8,1), limits=c(1,8)) +
  labs(y="Life Events Count", x="Time") +
  scale_color_manual(values=c(colour1, colour2, colour3, colour4), 
                     labels=c("low (9.0%)", "high (28.6%)", "medium (46.6%)", "medium-to-low (15.8%)"),
                     name="Trajectory Class") +
  scale_shape_manual(values=c(15,19,18,17),
                     labels=c("low (9.0%)", "high (28.6%)", "medium (46.6%)", "medium-to-low (15.8%)"),
                     name="Trajectory Class") +
  laura_theme() + theme(legend.position="none")
LEStrajectories
```

# Predicting trajectory class by resilience factors

Hypothesis 2:
Resilience factors assessed at baseline (optimism, self-care, social support, generalized self-efficacy) predict trajectory type. Higher scores are predictive of stable/increasing trajectories, lower scores predict decreasing trajectories.

Limitation: In cohort 3, actual T0 was 6 months before what is considered T0 in matched data used here.

## optimism
```{r optimism across latent classes}
# boxplot by class
optBoxPlot <- ggplot(data_wide, aes(class, LOT_T0_Optimismus, fill=class)) + 
  geom_violin() +  
  geom_boxplot(width=0.2, position=position_dodge(1)) +
  labs(y="Optimism", x="Class") +
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4)) +
  laura_theme()
optBoxPlot # no outliers

# get outlier IDs
optOutlierIDs <- data_wide %>%
  identify_outliers(LOT_T0_Optimismus)

# to be conservative and not exclude too much data, we will only consider extreme outliers
optOutlierIDs$Code[optOutlierIDs$is.extreme==T] # no extreme outliers

# check assumptions for one-way ANOVA
optModel  <- lm(LOT_T0_Optimismus ~ class, data = data_wide)

# homogeneity of variance
plot(optModel, 1) 
levene_test(optModel)

# normality of residuals
plot(optModel, 2)
shapiro.test(residuals(optModel)) 

# one-way ANOVA
opt.fit <- aov_ez("Code","LOT_T0_Optimismus", data_wide, between=c("class"))
nice(opt.fit, es="pes") # p < .001

# optimism by class
opt_class <- summarySE(data_wide, measurevar="LOT_T0_Optimismus", groupvars="class", conf.interval=.95) 
```

## self-care
```{r self-care across latent classes}
# boxplot by class
scrBoxPlot <- ggplot(data_wide, aes(class, HSF_T0_Gesamt, fill=class)) + 
  geom_violin() +  
  geom_boxplot(width=0.2, position=position_dodge(1)) +
  labs(y="Self-Care", x="Class") +
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4)) +
  laura_theme()
scrBoxPlot

# get outlier IDs
scrOutlierIDs <- data_wide %>%
  identify_outliers(HSF_T0_Gesamt)

# to be conservative and not exclude too much data, we will only consider extreme outliers
scrOutlierIDs$Code[scrOutlierIDs$is.extreme==T] # no extreme outliers

# check assumptions for one-way ANOVA
scrModel  <- lm(HSF_T0_Gesamt ~ class, data = data_wide)

# homogeneity of variance
plot(scrModel, 1) 
levene_test(scrModel)

# normality of residuals
plot(scrModel, 2)
shapiro.test(residuals(scrModel)) 

# run Kruskal-Wallis test instead of one-way ANOVA
kruskal.test(HSF_T0_Gesamt ~ class, data = data_wide) # sig. differences across groups

# self-care by class
scr_class <- summarySE(data_wide, measurevar="HSF_T0_Gesamt", groupvars="class", conf.interval=.95) 

data_wide %>% kruskal_effsize(HSF_T0_Gesamt ~ class)
```

## social support
```{r social support across latent classes}
# boxplot by class
socBoxPlot <- ggplot(data_wide, aes(class, FSOZ_T0_Gesamt, fill=class)) + 
  geom_violin() +  
  geom_boxplot(width=0.2, position=position_dodge(1)) +
  labs(y="Social Support", x="Class") +
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4)) +
  laura_theme()
socBoxPlot

# get outlier IDs
socOutlierIDs <- data_wide %>%
  identify_outliers(FSOZ_T0_Gesamt)

# check if extreme outlier
socOutlierIDs$Code[socOutlierIDs$is.extreme==T] # no extreme outlier

# check assumptions for one-way ANOVA
socModel  <- lm(FSOZ_T0_Gesamt ~ class, data = data_wide)

# homogeneity of variance
plot(socModel, 1) 
levene_test(socModel)

# normality of residuals
plot(socModel, 2)
shapiro.test(residuals(socModel)) 

# run Kruskal-Wallis test instead of one-way ANOVA
kruskal.test(FSOZ_T0_Gesamt ~ class, data = data_wide) # sig. differences across groups

data_wide %>% kruskal_effsize(FSOZ_T0_Gesamt ~ class)

# social support by class
soc_class <- summarySE(data_wide, measurevar="FSOZ_T0_Gesamt", groupvars="class", conf.interval=.95) 
```

## generalized self-efficacy
```{r gen. self-efficacy across latent classes}
# boxplot by class
gseBoxPlot <- ggplot(data_wide, aes(class, GSE_T0_Gesamt, fill=class)) + 
  geom_violin() +  
  geom_boxplot(width=0.2, position=position_dodge(1)) +
  labs(y="Gen. Self-Efficacy", x="Class") +
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4)) +
  laura_theme()
gseBoxPlot

# get outlier IDs
gseOutlierIDs <- data_wide %>%
  identify_outliers(GSE_T0_Gesamt)

# check if extreme outlier
gseOutlierIDs$Code[gseOutlierIDs$is.extreme==T] # no extreme outlier

# check assumptions for one-way ANOVA
gseModel  <- lm(GSE_T0_Gesamt ~ class, data = data_wide)

# homogeneity of variance
plot(gseModel, 1) 
levene_test(gseModel)

# normality of residuals
plot(gseModel, 2)
shapiro.test(residuals(gseModel)) 

# one-way ANOVA
gse.fit <- aov_ez("Code","GSE_T0_Gesamt", data_wide, between=c("class"))
nice(gse.fit, es="pes") # p < .001

# self-efficacy by class
gse_class <- summarySE(data_wide, measurevar="GSE_T0_Gesamt", groupvars="class", conf.interval=.95) 
```

## Multinomial logistic regression

### check data

no extreme outliers, see above

```{r check for multicollinearity}
# correlate predictors to check for multicollinearity (i.e., correlation coefficient r > .70)
corr <- data_wide %>%
  select(LOT_T0_Optimismus, HSF_T0_Gesamt, FSOZ_T0_Gesamt, GSE_T0_Gesamt)

c <- rcorr(as.matrix(corr)) # create correlation matrix
p.mat <- cor.mtest(corr)
# plot matrix
corrplot(c$r, # strength and direction of correlation
         method = "circle", # shape
         number.cex = .7, # size of shape
         addCoef.col = "black", # display correlation coefficient
         type = "lower", # show only lower half of matrix
         p.mat = p.mat$p, # get p values
         sig.level = .05, # set significance level
         insig = "blank", # do not color insignificant correlations
         cl.pos = "n", # remove color legend
         tl.srt = 90, # rotate text labels
         tl.col = "black", # label color
         diag = F) # hide diagonale
```

### run MLR model
```{r multinomial logistic regression}
# extract relevant variables
mlrdata <- data_wide %>%
  select(LOT_T0_Optimismus, HSF_T0_Gesamt, FSOZ_T0_Gesamt, GSE_T0_Gesamt, Age, Gender, Kohorte, class)

# factorize some variables
mlrdata$Gender <- as.factor(mlrdata$Gender)
mlrdata$Kohorte <- as.factor(mlrdata$Kohorte)

# dummy code DV
mlrdata_long <- mlogit.data(mlrdata, choice = "class", shape = "wide")

# mlr model
mlr.fit = mlogit(class ~ 1 | LOT_T0_Optimismus + HSF_T0_Gesamt + FSOZ_T0_Gesamt + GSE_T0_Gesamt + Age + Gender + Kohorte, data = mlrdata_long, reflevel = "low")
summary(mlr.fit)

# more self-care --> higher prob. of being in high/mediumlow vs. low class

data.frame(exp(mlr.fit$coefficients)) # get odds ratios
exp(confint(mlr.fit)) # get 95% CIs

correct <- mlr.fit$probabilities
binarycorrect <- colnames(correct)[apply(correct,1,which.max)]
table(mlrdata$class, binarycorrect)

# percentages
4/(1+4+5+2)*100 # low 33% correct, bad
20/(20+0+15+3)*100 # high 53% correct
51/(9+1+51+1)*100 # medium 82% correct
5/(3+2+11+5)*100 # medium-to-low only 24% correct, bad

(4+20+51+5)/nrow(mlrdata)*100 # 60% correct overall 
# so we're predicting better than chance, but small classes are badly predicted

# plot prediction accuracy
correct = as.data.frame(correct)
hist = ggplot(mlrdata, aes(correct$high, color=class, fill=class)) +
  geom_dotplot(binwidth = .01, position = "jitter") +
  coord_cartesian(xlim = c(0,1)) +
  labs(x="likelihood belonging in high class", y="Frequency") +
  scale_color_manual(values=c(colour1, colour2, colour3, colour4),
                     name="class") + 
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4),
                     name="class") +
  laura_theme()
hist
```

# Changes in stress and mental health from T3-T4 (impact of the pandemic)

```{r assessing pandemic impact}
PSS.mP <- mean(data_pandemic$PSS_P_Gesamt) # moderate perceived stress during pandemic (values > 27 would indicate high stress)
PSS.sdP <- sd(data_pandemic$PSS_P_Gesamt)
  
# pandemic-specific stressor load
hist_pandemic_stressor_count <- ggplot(data_pandemic, aes(x=COR_HS_P_Count)) + 
  geom_histogram(color="black", fill="gray") +
  scale_x_continuous(limits=c(0,29)) +
  labs(x="", title="Count of experienced pandemic-related stressors") +
  laura_theme()
hist_pandemic_stressor_count

COR_HS_P_Count.m <- mean(data_pandemic$COR_HS_P_Count)
COR_HS_P_Count.sd <- sd(data_pandemic$COR_HS_P_Count); 

hist_pandemic_stressor_intensity <- ggplot(data_pandemic, aes(x=COR_HS_P_mean_Intensity)) + 
  geom_histogram(color="black", fill="gray") +
  scale_x_continuous(limits=c(1,5)) +
  labs(x="not at all burdensome - extremely burdensome", title="Mean intensity of experienced pandemic-related stressors") +
  laura_theme()
hist_pandemic_stressor_intensity

COR_HS_P_int.m <- mean(data_pandemic$COR_HS_P_mean_Intensity)
COR_HS_P_int.sd <- sd(data_pandemic$COR_HS_P_mean_Intensity); 

data_wide_pandemic <- list(data_wide_pandemic, data_wide[, c(1,15,16,17,18)]) %>% reduce(left_join, by = "Code") # add T3 data

# paired t-tests to compare T3 and T4 stress
t.test(data_wide_pandemic$DH_T3_Frequency, data_wide_pandemic$DH_P_freq, paired = T)
mean(data_wide_pandemic$DH_T3_Frequency)
mean(data_wide_pandemic$DH_P_freq)

t.test(data_wide_pandemic$LES_T3_Count, data_wide_pandemic$LES_P_Count, paired = T)
mean(data_wide_pandemic$LES_T3_Count)
mean(data_wide_pandemic$LES_P_Count)

# paired t-tests to compare T3 and T4 mental health
t.test(data_wide_pandemic$BSI_T3_INV, data_wide_pandemic$BSI_P_GSI_INV, paired = T)
mean(data_wide_pandemic$BSI_T3_INV)
mean(data_wide_pandemic$BSI_P_GSI_INV)

t.test(data_wide_pandemic$WHO_T3_Prozentwert, data_wide_pandemic$WHO_P_Gesamt, paired = T)
mean(data_wide_pandemic$WHO_T3_Prozentwert)
mean(data_wide_pandemic$WHO_P_Gesamt)
```
Participants do not seem significantly more stressed during the pandemic than they were before - overall moderate levels of perceived stress (*M* = `r round(PSS.mP,2)`, *SD* = `r round(PSS.sdP,2)`). Of 29 pandemic-specific stressors, participants experienced on average `r COR_HS_P_Count.m` (*SD* = `r round(COR_HS_P_Count.sd,2)`) which they rated on a scale from 1 = "not at all burdensome" to 5 = "extremely burdensome". On average stressor intensity was reported as "a bit burdensome" (*M* = `r round(COR_HS_P_int.m,2)`, *SD* = `r round(COR_HS_P_int.sd,2)`).
The first lockdown in Germany may not have had as negative an impact on students as later restrictions. However, we would need data from another follow-up to be sure.

# Predicting resilience during the Corona pandemic

Hypothesis 3:
Resilient functioning during the pandemic differs depending on trajectory class, resilience factors, and perceived stress. Participants with stable/increasing trajectories show a more favourable response to the pandemic than participants with a decreasing trajectory.

## PSS during the pandemic
```{r PSS score during pandemic across latent classes}
# boxplot by class
pssPBoxPlot <- ggplot(data_wide_pandemic, aes(class, PSS_P_Gesamt, fill=class)) + 
  geom_violin() +  
  geom_boxplot(width=0.2, position=position_dodge(1)) +
  labs(y="PSS", x="Class") +
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4)) +
  laura_theme()
pssPBoxPlot

# get outlier IDs
pssPOutlierIDs <- data_wide_pandemic %>%
  identify_outliers(PSS_P_Gesamt) # none

# check assumptions for one-way ANOVA
pssPModel  <- lm(PSS_P_Gesamt ~ class, data = data_wide_pandemic)

# homogeneity of variance
plot(pssPModel, 1) 
levene_test(pssPModel)

# normality of residuals
plot(pssPModel, 2)
shapiro.test(residuals(pssPModel)) 

# one-way ANOVA
pssP.fit <- aov_ez("Code","PSS_P_Gesamt", data_wide_pandemic, between=c("class")) # sig. difference
nice(pssP.fit, es="pes") # get partial eta squared instead of generalised eta squared

# post-hoc comparisons
pssP <- emmeans(pssP.fit, ~ class)
pssP
pairs(pssP, adjust="holm")

# PSS during pandemic by class
pss_p_class <- summarySE(data_wide_pandemic, measurevar="PSS_P_Gesamt", groupvars="class", conf.interval=.95, na.rm=T) 
```

## Optimism during the pandemic
```{r LOT optimism score during pandemic across latent classes}
# boxplot by class
optPBoxPlot <- ggplot(data_wide_pandemic, aes(class, LOT_P_Optimismus, fill=class)) + 
  geom_violin() +  
  geom_boxplot(width=0.2, position=position_dodge(1)) +
  labs(y="Optimism", x="Class") +
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4)) +
  laura_theme()
optPBoxPlot

# get outlier IDs
optPOutlierIDs <- data_wide_pandemic %>%
  identify_outliers(LOT_P_Optimismus) # none

# check assumptions for one-way ANOVA
optPModel  <- lm(LOT_P_Optimismus ~ class, data = data_wide_pandemic)

# homogeneity of variance
plot(optPModel, 1) 
levene_test(optPModel)

# normality of residuals
plot(optPModel, 2)
shapiro.test(residuals(optPModel)) 

# one-way ANOVA
optP.fit <- aov_ez("Code","LOT_P_Optimismus", data_wide_pandemic, between=c("class")) # sig. difference
nice(optP.fit, es="pes") # get partial eta squared instead of generalised eta squared

# post-hoc comparisons
require(emmeans)
optP <- emmeans(optP.fit, ~ class)
optP
pairs(optP, adjust="holm")

# Optimism during pandemic by class
opt_p_class <- summarySE(data_wide_pandemic, measurevar="LOT_P_Optimismus", groupvars="class", conf.interval=.95, na.rm=T) 
```

## Self-Care during the pandemic
```{r HSF score during pandemic across latent classes}
# boxplot by class
scrPBoxPlot <- ggplot(data_wide_pandemic, aes(class, HSF_P_Gesamt, fill=class)) + 
  geom_violin() +  
  geom_boxplot(width=0.2, position=position_dodge(1)) +
  labs(y="Self-Care", x="Class") +
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4)) +
  laura_theme()
scrPBoxPlot

# get outlier IDs
scrPOutlierIDs <- data_wide_pandemic %>%
  identify_outliers(HSF_P_Gesamt) # none

# check assumptions for one-way ANOVA
scrPModel  <- lm(HSF_P_Gesamt ~ class, data = data_wide_pandemic)

# homogeneity of variance
plot(scrPModel, 1) 
levene_test(scrPModel)

# normality of residuals
plot(scrPModel, 2)
shapiro.test(residuals(scrPModel)) # sig.

# use Kruskal-Wallis test instead of ANOVA
kruskal.test(HSF_P_Gesamt ~ class, data_wide_pandemic) # p < .001

# Self-Care during pandemic by class
scr_p_class <- summarySE(data_wide_pandemic, measurevar="HSF_P_Gesamt", groupvars="class", conf.interval=.95, na.rm=T) 
```

## FSozU was used at T0, it also has components assessing emotional and practical (i.e. instrumental) support so should correlated with these BSSS scales

## BSSS score - perceived emotional support
```{r BSSS - perceived emotional support score during pandemic across latent classes}
# boxplot by class
bsssPESBoxPlot <- ggplot(data_wide_pandemic, aes(class, BSSS_P_perEmoSupport, fill=class)) + 
  geom_violin() +  
  geom_boxplot(width=0.2, position=position_dodge(1)) +
  labs(y="BSSS - perceived emotional support", x="Class") +
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4)) +
  laura_theme()
bsssPESBoxPlot

# get outlier IDs
bsssPESOutlierIDs <- data_wide_pandemic %>%
  identify_outliers(BSSS_P_perEmoSupport) # 5

# check if extreme outlier
bsssPESOutlierIDs$Code[bsssPESOutlierIDs$is.extreme==T] # no extreme outlier

# check assumptions for one-way ANOVA
bsssPESModel  <- lm(BSSS_P_perEmoSupport ~ class, data = data_wide_pandemic)

# homogeneity of variance
plot(bsssPESModel, 1) 
levene_test(bsssPESModel)

# normality of residuals
plot(bsssPESModel, 2)
shapiro.test(residuals(bsssPESModel)) 

# use Kruskal-Wallis test instead of ANOVA
kruskal.test(BSSS_P_perEmoSupport ~ class, data_wide_pandemic) # p < .01

# BSSS - perceived emotional support score during the pandemic by class
bsssPES_class <- summarySE(data_wide_pandemic, measurevar="BSSS_P_perEmoSupport", groupvars="class", conf.interval=.95, na.rm=T)
```

## BSSS score - perceived instrumental support
```{r BSSS - perceived instrumental support score during pandemic across latent classes}
# boxplot by class
bsssPISBoxPlot <- ggplot(data_wide_pandemic, aes(class, BSSS_P_perInstSupport, fill=class)) + 
  geom_violin() +  
  geom_boxplot(width=0.2, position=position_dodge(1)) +
  labs(y="BSSS - perceived instrumental support", x="Class") +
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4)) +
  laura_theme()
bsssPISBoxPlot

# get outlier IDs
bsssPISOutlierIDs <- data_wide_pandemic %>%
  identify_outliers(BSSS_P_perInstSupport) # 2

# check if extreme outlier
bsssPISOutlierIDs$Code[bsssPISOutlierIDs$is.extreme==T] # no extreme outlier

# check assumptions for one-way ANOVA
bsssPISModel  <- lm(BSSS_P_perInstSupport ~ class, data = data_wide_pandemic)

# homogeneity of variance
plot(bsssPISModel, 1) 
levene_test(bsssPISModel)

# normality of residuals
plot(bsssPISModel, 2)
shapiro.test(residuals(bsssPISModel)) 

# use Kruskal-Wallis test instead of ANOVA
kruskal.test(BSSS_P_perInstSupport ~ class, data_wide_pandemic) # p < .01

# BSSS - perceived instrumental support score during the pandemic by class
bsssPIS_class <- summarySE(data_wide_pandemic, measurevar="BSSS_P_perInstSupport", groupvars="class", conf.interval=.95, na.rm=T)
```

## GSE during the pandemic
```{r GSE score during pandemic across latent classes}
# boxplot by class
gsePBoxPlot <- ggplot(data_wide_pandemic, aes(class, GSE_P_Gesamt, fill=class)) + 
  geom_violin() +  
  geom_boxplot(width=0.2, position=position_dodge(1)) +
  labs(y="GSE score", x="Class") +
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4)) +
  laura_theme()
gsePBoxPlot

# get outlier IDs
gsePOutlierIDs <- data_wide_pandemic %>%
  identify_outliers(GSE_P_Gesamt) # 6

# check if extreme outlier
gsePOutlierIDs$Code[gsePOutlierIDs$is.extreme==T] # no extreme outlier

# check assumptions for one-way ANOVA
gsePModel  <- lm(GSE_P_Gesamt ~ class, data = data_wide_pandemic)

# homogeneity of variance
plot(gsePModel, 1) 
levene_test(gsePModel)

# normality of residuals
plot(gsePModel, 2)
shapiro.test(residuals(gsePModel)) 

# use Kruskal-Wallis test instead of ANOVA
kruskal.test(GSE_P_Gesamt ~ class, data_wide_pandemic) # p < .001

# GSE score during the pandemic by class
gseP_class <- summarySE(data_wide_pandemic, measurevar="GSE_P_Gesamt", groupvars="class", conf.interval=.95, na.rm=T) 
```

## Resilience during the pandemic
```{r resilient functioning during pandemic}
# boxplot by class
RFPBoxPlot <- ggplot(data_wide_pandemic, aes(class, RF_P, fill=class)) + 
  geom_violin() +  
  geom_boxplot(width=0.2, position=position_dodge(1)) +
  labs(y="Resilient Functioning", x="Class") +
  scale_fill_manual(values=c(colour1, colour2, colour3, colour4)) +
  laura_theme()
RFPBoxPlot

# get outlier IDs
RFPOutlierIDs <- data_wide_pandemic %>%
  identify_outliers(RF_P) 

# check if extreme outlier
RFPOutlierIDs$Code[RFPOutlierIDs$is.extreme==T] # no extreme outlier

# check assumptions for one-way ANOVA
RFPModel  <- lm(RF_P ~ class, data = data_wide_pandemic)

# homogeneity of variance
plot(RFPModel, 1) 
levene_test(RFPModel)

# normality of residuals
plot(RFPModel, 2)
shapiro.test(residuals(RFPModel)) 

RFP.fit <- aov_ez("Code","RF_P", data_wide_pandemic, between=c("class")) # sig. difference
nice(RFP.fit, es="pes") # get partial eta squared instead of generalised eta squared

# post-hoc comparisons
RFP <- emmeans(RFP.fit, ~ class)
RFP
pairs(RFP, adjust="holm")

# Resilient Functioning during the pandemic by class
RFP_class <- summarySE(data_wide_pandemic, measurevar="RF_P", groupvars="class", conf.interval=.95, na.rm=T) 
```

## Multiple Regression

```{r resilient functioning - regression model}
# test whether resilient functioning during the pandemic differed between classes

# mean center predictors
data_wide_pandemic <- data_wide_pandemic %>%
    mutate(LOT_P_Optimismus.c = center_this(LOT_P_Optimismus),
           HSF_P_Gesamt.c = center_this(HSF_P_Gesamt),
           BSSS_P_perEmoSupport.c = center_this(BSSS_P_perEmoSupport),
           GSE_P_Gesamt.c = center_this(GSE_P_Gesamt),
           PSS_P_Gesamt.c = center_this(PSS_P_Gesamt),
           Age.c = center_this(Age))

# check all variables for normality, homogeneity of variance, and linearity
panel.bxp <- function(x, ...) {
    usr <- par("usr")
    on.exit(par(usr))
    par(usr = c(usr[1:2], 0, 2))
    boxplot(x, add = TRUE, horizontal = T)
}
pairs(~RF_P + LOT_P_Optimismus.c + HSF_P_Gesamt.c + BSSS_P_perEmoSupport.c + GSE_P_Gesamt.c + PSS_P_Gesamt.c, data = data_wide_pandemic, lower.panel = panel.smooth,
    diag.panel = panel.bxp, upper.panel = NULL, gap = 0)

# change order of factor levels to set low class as reference
data_wide_pandemic$class <- relevel(data_wide_pandemic$class, ref="low")
  
# model
pandemic_model <- lm(RF_P ~ class + LOT_P_Optimismus.c + HSF_P_Gesamt.c + BSSS_P_perEmoSupport.c + GSE_P_Gesamt.c + PSS_P_Gesamt.c, data_wide_pandemic)
summary(pandemic_model)
confint(pandemic_model) # get confidence intervals
lm.beta(pandemic_model) # get standardized betas

# model with covariates
pandemic_model.cov <- update(pandemic_model, .~. + Age.c + Gender + Kohorte)
summary(pandemic_model.cov)

# model comparison
anova(pandemic_model, pandemic_model.cov) # n.s.

# model with interaction terms
pandemic_model.int <- update(pandemic_model, .~. + class:HSF_P_Gesamt.c)
summary(pandemic_model.int)

# model comparison
anova(pandemic_model, pandemic_model.int)

confint(pandemic_model.int) # get confidence intervals
lm.beta(pandemic_model.int) # get standardized betas
```

```{r regression model diagnostics}
# homogeneity of variance
plot(pandemic_model, 1) 

# normality of residuals
plot(pandemic_model, 2)
shapiro.test(residuals(pandemic_model)) 

# save diagnostics
data_wide_pandemic$standardized.residuals <- rstandard(pandemic_model)
data_wide_pandemic$large.residual <- data_wide_pandemic$standardized.residuals > 2 | data_wide_pandemic$standardized.residuals < -2
sum(data_wide_pandemic$large.residual) # 6 --> 5.6%
data_wide_pandemic[data_wide_pandemic$large.residual, c("Code", "class", "standardized.residuals") ]
data_wide_pandemic$cooks.distance <- cooks.distance(pandemic_model)
data_wide_pandemic$leverage <- hatvalues(pandemic_model)
data_wide_pandemic$covariance.ratios <- covratio(pandemic_model)

data_wide_pandemic[data_wide_pandemic$large.residual, c("Code", "cooks.distance", "leverage", "covariance.ratios") ] # DI22LUIS has rather large leverage value

par(mfrow = c(2, 3))
plot(pandemic_model, ask = F, which = 1:6)
hist(rstudent(pandemic_model))

# Durbin-Watson Test
dwt(pandemic_model)

# check multicollinearity
vif <- as.data.frame(vif(pandemic_model)[, 1:3])
1/vif(pandemic_model)
mean(vif(pandemic_model))
```